# Joplin 导出模块触发机制

## 概述

Joplin 插件的导出模块通过 `joplin.interop.registerExportModule()` 注册后，会在用户执行导出操作时按特定顺序触发各个事件处理器。本文档基于实际日志分析，详细说明 `onProcessItem` 和 `onProcessResource` 的触发时机和机制。

## 导出流程事件序列

### 完整事件触发顺序

```
用户选择导出操作
    ↓
1. onInit(context) - 初始化导出环境
    ↓
2. onProcessItem(context, itemType, item) - 处理文件夹、笔记、资源（类型4）
    ↓
3. onProcessResource(context, resource, filePath) - 处理资源文件
    ↓
4. onClose(context) - 保存文件并清理缓存
    ↓
导出完成
```

### 实际日志分析

根据 `demo.log` 的实际导出记录，触发顺序如下：

```
[2026-02-04T06:10:22.664Z] onInit 开始
    ↓
[2026-02-04T06:10:22.672Z] onInit 结束
    ↓
[2026-02-04T06:10:22.674Z] onProcessItem 开始 (itemType: 2, Folder)
[2026-02-04T06:10:22.674Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.676Z] onProcessResource 开始 (资源1)
[2026-02-04T06:10:22.681Z] onProcessResource 结束
    ↓
[2026-02-04T06:10:22.683Z] onProcessItem 开始 (itemType: 4, Resource)
[2026-02-04T06:10:22.683Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.685Z] onProcessResource 开始 (资源2)
[2026-02-04T06:10:22.689Z] onProcessResource 结束
    ↓
[2026-02-04T06:10:22.690Z] onProcessItem 开始 (itemType: 4, Resource)
[2026-02-04T06:10:22.690Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.690Z] onProcessResource 开始 (资源3)
[2026-02-04T06:10:22.693Z] onProcessResource 结束
    ↓
[2026-02-04T06:10:22.694Z] onProcessItem 开始 (itemType: 4, Resource)
[2026-02-04T06:10:22.694Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.695Z] onProcessResource 开始 (资源4)
[2026-02-04T06:10:22.699Z] onProcessResource 结束
    ↓
[2026-02-04T06:10:22.699Z] onProcessItem 开始 (itemType: 4, Resource)
[2026-02-04T06:10:22.699Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.700Z] onProcessResource 开始 (资源5)
[2026-02-04T06:10:22.703Z] onProcessResource 结束
    ↓
[2026-02-04T06:10:22.703Z] onProcessItem 开始 (itemType: 4, Resource)
[2026-02-04T06:10:22.704Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.704Z] onProcessItem 开始 (itemType: 1, Note: ESXi-r740)
[2026-02-04T06:10:22.706Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.706Z] onProcessItem 开始 (itemType: 1, Note: ESXi-vSwitch的作用)
[2026-02-04T06:10:22.708Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.708Z] onProcessItem 开始 (itemType: 1, Note: ESXi-技术外援)
[2026-02-04T06:10:22.710Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.710Z] onProcessItem 开始 (itemType: 1, Note: ESXi-支持日志)
[2026-02-04T06:10:22.712Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.712Z] onProcessItem 开始 (itemType: 1, Note: ESXi-端口组与网卡映射的作用)
[2026-02-04T06:10:22.713Z] onProcessItem 结束
    ↓
[2026-02-04T06:10:22.714Z] onClose 开始
    ↓
[2026-02-04T06:10:22.716Z] 笔记已保存
    ↓
[2026-02-04T06:10:22.760Z] onClose 结束
```

### 关键发现

1. **交替触发模式**：`onProcessItem(itemType: 4)` 和 `onProcessResource` 交替触发
   - 先触发 `onProcessItem(itemType: 4)` - 通知资源元数据
   - 紧接着触发 `onProcessResource` - 处理资源文件

2. **资源处理的两次触发**：
   - 第一次：`onProcessItem(itemType: 4)` - 仅传递资源 ID
   - 第二次：`onProcessResource` - 提供完整文件路径进行实际处理

3. **文件夹优先**：首先处理文件夹（`itemType: 2`），然后处理资源和笔记

4. **笔记最后处理**：所有资源和文件夹处理完后，才处理笔记（`itemType: 1`）

## 详细触发时机

### 1. onInit(context)

**触发时机**：导出过程开始时，在处理任何项目之前

**实际日志**：
```
[2026-02-04T06:10:22.664Z] [DEBUG] [函数调用] onInit 开始 { destPath: "C:\\Users\\xxx\\Downloads\\04_02_2026.md" }
[2026-02-04T06:10:22.668Z] [INFO] 当前导出路径样式 { rawValue: 1, styleName: "层次结构" }
[2026-02-04T06:10:22.669Z] [INFO] 层次结构模式：开始预加载所有文件夹信息
[2026-02-04T06:10:22.672Z] [INFO] 文件夹预加载完成，共加载 26 个文件夹
[2026-02-04T06:10:22.672Z] [DEBUG] [函数调用] onInit 结束
```

**用途**：
- 清空缓存
- 获取导出配置（路径样式、合并内容开关）
- 预加载文件夹信息（层次结构模式）

### 2. onProcessItem(context, itemType, item)

**触发时机**：遍历所有 Joplin 对象时触发

**itemType 类型**：
| 值 | 类型 | 说明 |
|----|------|------|
| 1 | Note | 笔记 |
| 2 | Folder | 文件夹/笔记本 |
| 4 | Resource | 资源元数据 |
| 5 | Tag | 标签 |

**实际日志分析**：

#### 文件夹处理（itemType: 2）
```
[2026-02-04T06:10:22.674Z] onProcessItem 开始 { itemType: 2, itemId: "ec8031c8..." }
[2026-02-04T06:10:22.674Z] onProcessItem 结束
```
- 层次结构模式下，文件夹信息已在 onInit 预加载，此处跳过

#### 资源元数据（itemType: 4）
```
[2026-02-04T06:10:22.683Z] onProcessItem 开始 { itemType: 4, itemId: "7fe70bf5..." }
[2026-02-04T06:10:22.683Z] onProcessItem 结束
```
- 仅通知资源 ID，不提供文件路径
- 紧接着会触发 `onProcessResource` 处理实际文件

#### 笔记处理（itemType: 1）
```
[2026-02-04T06:10:22.704Z] onProcessItem 开始 { itemType: 1, itemId: "15c88f27...", title: "ESXi-r740" }
[2026-02-04T06:10:22.705Z] 获取笔记完整属性
[2026-02-04T06:10:22.705Z] processYamlFrontmatter 开始
[2026-02-04T06:10:22.706Z] 无原有YAML，生成新前沿信息
[2026-02-04T06:10:22.706Z] 笔记处理完成，已加入全局缓存
[2026-02-04T06:10:22.706Z] onProcessItem 结束
```

**重要特性**：
- `itemType: 4` 仅传递资源元数据，不包含文件路径
- `itemType: 1` 包含笔记完整信息（body、created_time、updated_time 等）
- 笔记在资源和文件夹处理完后才触发

### 3. onProcessResource(context, resource, filePath)

**触发时机**：每遇到一个资源文件时触发，紧随 `onProcessItem(itemType: 4)` 之后

**实际日志**：
```
[2026-02-04T06:10:22.676Z] onProcessResource 开始 { resourceId: "76d6eb45...", filePath: "C:/Users/xxx/.config/joplin-desktop/resources/..." }
[2026-02-04T06:10:22.676Z] 获取资源完整属性
[2026-02-04T06:10:22.679Z] resourceNotes: { items: [{ id: "15c88f27...", parent_id: "ec8031c8..." }] }
[2026-02-04T06:10:22.679Z] 层次结构资源路径计算
[2026-02-04T06:10:22.680Z] 创建文件夹和assets目录
[2026-02-04T06:10:22.681Z] 资源复制完成
[2026-02-04T06:10:22.681Z] 资源映射已记录
[2026-02-04T06:10:22.681Z] onProcessResource 结束
```

**关键点**：
- `filePath` 是资源在 Joplin 内部存储的完整路径
- 需要主动查询 `joplin.data.get(["resources", resourceId, "notes"])` 获取关联笔记
- 每个资源只触发一次 `onProcessResource`

### 4. onClose(context)

**触发时机**：所有项目和资源处理完成后

**实际日志**：
```
[2026-02-04T06:10:22.714Z] onClose 开始 { destPath: "C:\\Users\\xxx\\Downloads\\04_02_2026.md" }
[2026-02-04T06:10:22.714Z] 开始分别保存 5 个笔记
[2026-02-04T06:10:22.715Z] replaceResourceLinks 开始
[2026-02-04T06:10:22.715Z] 资源链接替换：![esxi图形化管理1](:/ba1e1695...) -> ![esxi图形化管理1](./assets/esxi图形化管理1.png)
[2026-02-04T06:10:22.716Z] 笔记已保存：C:\Users\xxx\Downloads\Notes\科研工作\计算机与代码\esxi\ESXi-r740.md
[2026-02-04T06:10:22.760Z] 导出成功！共保存 5 个笔记
[2026-02-04T06:10:22.760Z] 全局缓存已重置
[2026-02-04T06:10:22.760Z] onClose 结束
```

**用途**：
- 替换资源链接（`:/资源ID` → `./assets/文件名`）
- 保存笔记文件到磁盘
- 清理全局缓存

## 触发顺序总结

### 完整触发顺序（基于实际日志）

```
1. onInit
   ├─ 清空缓存
   ├─ 获取配置
   └─ 预加载文件夹（层次结构模式）

2. onProcessItem (itemType: 2, Folder)
   └─ 跳过（已预加载）

3. 资源处理循环（重复多次）
   ├─ onProcessItem (itemType: 4, Resource)
   │  └─ 通知资源 ID
   │
   └─ onProcessResource
      ├─ 获取资源详细信息
      ├─ 查询关联笔记
      ├─ 复制资源文件
      └─ 记录资源映射

4. 笔记处理循环
   └─ onProcessItem (itemType: 1, Note)
      ├─ 获取笔记完整信息
      ├─ 处理 YAML Frontmatter
      └─ 保存到缓存

5. onClose
   ├─ 替换资源链接
   ├─ 保存笔记文件
   ├─ 记录导出结果
   └─ 清理缓存
```

### 关键时序图

```
时间轴 →

onInit                        onProcessItem(2)     onProcessItem(4)  onProcessResource  onProcessItem(1)  onClose
  │                               │                    │                  │                  │            │
  ├─ 初始化                       ├─ 跳过              ├─ 通知资源ID      ├─ 处理资源文件    ├─ 处理笔记    ├─ 保存文件
  ├─ 清空缓存                     │                    │                  ├─ 查询关联笔记    ├─ 生成YAML    ├─ 清理缓存
  └─ 预加载文件夹                 │                    │                  ├─ 复制文件        ├─ 保存到缓存  └─ 完成
                                  │                    │                  └─ 记录映射
```

## 关键注意事项

### 1. 资源的两次触发

每个资源会触发两次：
1. `onProcessItem(itemType: 4)` - 元数据通知
2. `onProcessResource` - 实际文件处理

**原因**：Joplin 的导出机制将元数据和文件处理分离，先遍历所有对象通知元数据，再处理实际文件。

### 2. itemType: 4 的处理方式

在 `onProcessItem` 中，`itemType: 4` 只提供资源 ID，不提供文件路径：

```typescript
if (itemType === ModelType.Resource) {
  // 不要在这里处理资源文件
  // 只记录或跳过即可
  return;
}
```

实际文件处理在 `onProcessResource` 中进行。

### 3. 异步处理顺序

虽然日志显示顺序正确，但由于：
- 文件写入是异步的（不等待完成）
- 多个资源可能并行处理

**实际文件写入顺序可能与日志顺序不同**，但时间戳可以反映真实调用顺序。

### 4. 资源与笔记的关联

在层次结构模式下：
- `onProcessResource` 处理资源时，笔记还未被处理
- 需要通过 `resourceNotes` 查询获取笔记的 `parent_id`
- 使用 `buildFolderPath()` 构建完整路径

## 实际应用示例

### 层次结构导出完整流程

```typescript
// 1. onInit: 预加载文件夹
onInit: async function(context: any) {
  exportGlobalCache.exportPathStyle = await getExportPathStyle();

  if (exportGlobalCache.exportPathStyle === ExportPathStyle.Hierarchical) {
    const allFolders = await joplin.data.get(["folders"]);
    for (const folder of allFolders.items) {
      exportGlobalCache.folderMap.set(folder.id, folder);
    }
  }
}

// 2. onProcessItem: 处理笔记（跳过文件夹和资源元数据）
onProcessItem: async function(context: any, itemType: number, item: any) {
  if (itemType === ModelType.Folder) {
    // 层次结构模式：已预加载，跳过
    return;
  }

  if (itemType === ModelType.Resource) {
    // 资源元数据，不处理，等待 onProcessResource
    return;
  }

  if (itemType === ModelType.Note) {
    const note = await joplin.data.get(["notes", item.id]);

    // 记录笔记与文件夹的关联
    if (note.parent_id) {
      exportGlobalCache.noteFolderMap.set(note.id, note.parent_id);
    }

    // 处理 YAML Frontmatter
    const processedBody = processYamlFrontmatter(note.body, note);

    // 保存到缓存
    exportGlobalCache.notes.set(note.id, {
      id: note.id,
      title: note.title,
      content: processedBody,
      folderId: note.parent_id,
      fileName: `${note.title}.md`,
    });
  }
}

// 3. onProcessResource: 处理资源文件
onProcessResource: async function(context: any, resource: any, filePath: string) {
  const resDetail = await joplin.data.get(["resources", resource.id]);
  const resourceNotes = await joplin.data.get(["resources", resDetail.id, "notes"]);

  for (const noteItem of resourceNotes.items) {
    const folderId = noteItem.parent_id;
    const folderPath = buildFolderPath(folderId, destDir);
    const assetsDir = path.join(folderPath, "assets");

    // 复制资源文件
    await fs.copyFile(filePath, path.join(assetsDir, resDetail.title));

    // 记录资源映射
    const resourceKey = `${noteItem.id}_${resDetail.id}`;
    exportGlobalCache.resourceMap.set(resourceKey, `./assets/${resDetail.title}`);
  }
}

// 4. onClose: 保存文件并清理
onClose: async function(context: any) {
  for (const [noteId, noteInfo] of exportGlobalCache.notes) {
    // 替换资源链接
    const processedContent = replaceResourceLinks(noteInfo.content, noteId);

    // 构建文件路径
    const folderPath = buildFolderPath(noteInfo.folderId, destDir);
    const notePath = path.join(folderPath, noteInfo.fileName);

    // 保存文件
    await fs.writeFile(notePath, processedContent, "utf8");
  }

  // 清理缓存
  exportGlobalCache.notes.clear();
  exportGlobalCache.resourceMap.clear();
}
```

## 常见问题

### Q1: 为什么会有 itemType: 4 的 onProcessItem 调用？

这是 Joplin 导出机制的设计，用于先遍历所有对象通知元数据，然后再处理实际文件。在 `onProcessItem(itemType: 4)` 中应该跳过处理，等待 `onProcessResource` 被调用。

### Q2: 资源和笔记的处理顺序是什么？

顺序是：
1. 文件夹（itemType: 2）
2. 资源元数据（itemType: 4）+ 资源文件处理（onProcessResource）交替
3. 笔记（itemType: 1）

### Q3: 如何在层次结构模式下正确处理资源？

关键点：
- 在 `onProcessResource` 中查询 `resourceNotes` 获取笔记的 `parent_id`
- 使用 `buildFolderPath()` 构建完整文件夹路径
- 使用 `noteId_resourceId` 作为资源映射的键，避免冲突

### Q4: 日志顺序是否等于实际执行顺序？

基本是的，但由于文件写入是异步的，实际文件写入顺序可能与日志不同。时间戳可以反映真实的调用顺序。

## 参考资料

- [Joplin Plugin API - ExportModule](https://joplinapp.org/api/references/plugin_api/interfaces/exportmodule.html)
- [Joplin Plugin API - JoplinInterop](https://joplinapp.org/api/references/plugin_api/classes/joplininterop.html)
- [Joplin API Types](api/types.ts)
- [导出功能.md](导出功能.md) - 导出功能详细说明