# Joplin 插件 - 外部编辑器按钮功能需求分析

## 一、需求背景

### 1.1 现状分析

Joplin 原生提供了一个"切换外部编辑器"功能，允许用户在外部编辑器（如 Typora、VS Code 等）中编辑当前笔记。该功能在工具栏中有一个切换按钮，点击后会在外部编辑器中打开当前笔记。

但是，原生的外部编辑器功能存在以下限制：

1. **无法干预导出过程**：导出格式固定，无法自定义导出逻辑
2. **无法干预导入过程**：导入回 Joplin 时无法处理特殊的资源链接或元数据
3. **无法添加中间处理步骤**：无法在导出和导入之间执行自定义操作

### 1.2 核心需求

用户希望在 Joplin 编辑器工具栏添加一个自定义按钮，实现以下功能：

1. **导出当前笔记**：将当前正在编辑的笔记导出为 Markdown 文件
2. **打开外部编辑器**：在外部编辑器（如 Typora）中打开导出的文件
3. **监控文件变化**：监听外部编辑器的保存操作
4. **导入回 Joplin**：将外部编辑器修改后的内容导入回 Joplin
5. **自定义处理**：在导出和导入过程中可以插入自定义逻辑

### 1.3 与现有功能的关系

本插件已经实现了：
- **导出模块**：通过 `joplin.interop.registerExportModule()` 注册的导出功能
- **导入模块**：通过 `joplin.interop.registerImportModule()` 注册的导入功能

新的外部编辑器按钮将复用这些导出和导入逻辑，但提供更流畅的编辑体验。

## 二、需求分析

### 2.1 功能需求

#### FR1: 工具栏按钮

在 Joplin 编辑器工具栏添加一个"Typora"按钮。

**优先级**：高

**描述**：
- 按钮位置：编辑器工具栏
- 按钮文本："Typora"
- 按钮图标：Typora 图标或通用编辑器图标
- 按钮状态：只有在选中笔记时可用

#### FR2: 导出当前笔记

点击按钮后，导出当前选中的笔记到临时目录。

**优先级**：高

**描述**：
- 获取当前选中的笔记
- 使用现有的导出逻辑导出笔记
- 导出路径：临时目录，如插件的文件日志的同级目录，joplin.plugins.dataDir()
- 文件名：使用笔记标题作为文件名
- 包含资源：同时导出笔记中的所有资源文件

#### FR3: 打开外部编辑器

导出完成后，自动在外部编辑器中打开导出的文件。

**优先级**：高

**描述**：
- 支持配置外部编辑器路径（如 Typora、VS Code 等）
- 自动打开导出的 Markdown 文件
- 传递正确的文件路径给外部编辑器

#### FR4: 监控文件变化

监听外部编辑器对文件的修改。

**优先级**：中

**描述**：
- 监听导出的 Markdown 文件的变化
- 检测到文件修改时提示用户
- 提供同步选项：立即同步、稍后同步、忽略

#### FR5: 导入回 Joplin

将外部编辑器修改后的内容同步回 Joplin。

**优先级**：高

**描述**：
- 使用现有的导入逻辑导入修改后的内容
- 更新笔记的标题、正文、创建时间、更新时间
- 处理资源文件的变更（新增、删除、修改）
- 保留 Joplin 的元数据（如标签、笔记本等）

#### FR6: 配置选项

提供插件配置选项，让用户自定义行为。

**优先级**：中

**描述**：
- 外部编辑器路径配置
- 临时目录配置
- 自动同步开关
- 同步间隔配置

### 2.2 非功能需求

#### NFR1: 性能

- 导出操作应在 2 秒内完成（普通笔记）
- 导入操作应在 3 秒内完成（普通笔记）

#### NFR2: 可靠性

- 确保数据不丢失
- 处理编辑器崩溃等异常情况
- 提供冲突解决机制（当 Joplin 和外部编辑器同时修改时）

#### NFR3: 易用性

- 一键操作，无需复杂配置
- 提供清晰的状态提示
- 错误信息友好易懂

#### NFR4: 兼容性

- 支持 Windows、macOS、Linux
- 支持多种外部编辑器（Typora、VS Code、Obsidian 等）

## 三、技术实现思路

### 3.1 架构设计

```
用户点击"Typora"按钮
    ↓
1. 获取当前笔记信息
    ↓
2. 导出笔记到临时目录（复用 exporter.ts）
    ↓
3. 启动外部编辑器打开文件
    ↓
4. 监听文件变化（可选）
    ↓
5. 用户编辑完成并保存
    ↓
6. 导入修改后的内容（复用 importer.ts）
    ↓
7. 更新 Joplin 中的笔记
```

### 3.2 核心组件

#### 组件 1: 工具栏按钮管理器 (ToolbarButtonManager)

**职责**：
- 注册工具栏按钮
- 处理按钮点击事件
- 管理按钮状态

**使用 API**：
- `joplin.views.toolbarButtons.create()`
- `joplin.commands.register()`

**代码位置**：`src/toolbarButton.ts`（新建）

#### 组件 2: 外部编辑器管理器 (ExternalEditorManager)

**职责**：
- 启动外部编辑器
- 配置编辑器路径
- 处理编辑器进程

**使用 API**：
- Node.js `child_process.exec()` 或 `child_process.spawn()`
- 平台特定的命令：Windows (`start`)、macOS (`open`)、Linux (`xdg-open`)

**代码位置**：`src/externalEditor.ts`（新建）

#### 组件 3: 同步管理器 (SyncManager)

**职责**：
- 监听文件变化
- 触发同步操作
- 处理冲突

**使用 API**：
- Node.js `fs.watch()` 或 `chokidar` 库
- `joplin.workspace.selectedNote()`
- `joplin.data.put()`

**代码位置**：`src/syncManager.ts`（新建）

#### 组件 4: 临时文件管理器 (TempFileManager)

**职责**：
- 创建临时目录
- 清理临时文件
- 管理文件生命周期

**使用 API**：
- Node.js `fs-extra`
- 操作系统临时目录：`os.tmpdir()`

**代码位置**：`src/tempFileManager.ts`（新建）

### 3.3 关键技术点

#### 3.3.1 工具栏按钮注册

使用 `joplin.views.toolbarButtons.create()` 注册按钮：

```typescript
// 注册命令
await joplin.commands.register({
  id: 'openInTypora',
  title: 'Typora',
  execute: async () => {
    // 处理按钮点击
  },
});

// 创建工具栏按钮
await joplin.views.toolbarButtons.create(
  'openInTyporaButton',  // 按钮ID
  'openInTypora',        // 关联的命令
  ToolbarButtonLocation.NoteToolbar  // 按钮位置
);
```

#### 3.3.2 获取当前笔记

```typescript
const selectedNote = await joplin.workspace.selectedNote();
if (!selectedNote) {
  logger.warn("没有选中的笔记");
  return;
}
```

#### 3.3.3 导出笔记到临时目录

复用现有的导出逻辑，但需要修改为支持单个笔记导出到指定路径：

```typescript
// 在 exporter.ts 中添加新函数
export const exportNoteToPath = async (
  noteId: string,
  destPath: string,
  exportPathStyle: ExportPathStyle
): Promise<void> => {
  // 初始化缓存
  const cache = await initExportCache(exportPathStyle, false);

  // 获取笔记信息
  const note = await joplin.data.get(["notes", noteId], {
    fields: ["id", "title", "body", "created_time", "updated_time", "author", "parent_id"],
  });

  // 处理笔记
  await processNoteItem(note, cache);

  // 获取笔记的资源
  const resources = await joplin.data.get(["notes", noteId, "resources"]);

  // 处理资源
  for (const resource of resources.items) {
    const resourcePath = await joplin.data.resourcePath(resource.id);
    await processResourceItem(resource, resourcePath, cache, destPath);
  }

  // 完成导出
  await finalizeExport(cache, destPath);
};
```

#### 3.3.4 启动外部编辑器

```typescript
export const openInExternalEditor = async (
  filePath: string,
  editorPath: string
): Promise<void> => {
  const { exec } = require('child_process');
  const os = require('os');

  const platform = os.platform();

  let command: string;

  if (platform === 'win32') {
    // Windows
    command = `start "" "${editorPath}" "${filePath}"`;
  } else if (platform === 'darwin') {
    // macOS
    command = `open -a "${editorPath}" "${filePath}"`;
  } else {
    // Linux
    command = `${editorPath} "${filePath}"`;
  }

  exec(command, (error, stdout, stderr) => {
    if (error) {
      logger.error('启动外部编辑器失败', { error, stderr });
    } else {
      logger.info('外部编辑器已启动');
    }
  });
};
```

#### 3.3.5 监听文件变化

```typescript
import * as chokidar from 'chokidar';

export const watchFileChanges = (
  filePath: string,
  onChange: (path: string) => void
): fs.FSWatcher => {
  const watcher = chokidar.watch(filePath, {
    persistent: true,
    ignoreInitial: true,
  });

  watcher.on('change', (path) => {
    logger.info('检测到文件变化', { path });
    onChange(path);
  });

  return watcher;
};
```

#### 3.3.6 导入修改后的内容

复用现有的导入逻辑：

```typescript
// 读取修改后的文件
const modifiedContent = await fs.readFile(modifiedFilePath, 'utf8');

// 导入到 Joplin
const importResult = await importMarkdown(
  modifiedContent,
  modifiedFilePath,
  selectedNote.parent_id,
  selectedNote.title
);

// 更新笔记（不创建新笔记，而是更新现有笔记）
if (importResult.success && importResult.noteId) {
  await joplin.data.put(['notes', selectedNote.id], null, {
    body: modifiedContent,
  });
}
```

### 3.4 数据流

```
用户点击按钮
    ↓
[ToolbarButtonManager] 接收点击事件
    ↓
[SyncManager] 检查是否有正在编辑的笔记
    ↓
[TempFileManager] 创建临时目录
    ↓
[Exporter] 导出笔记到临时目录
    ↓
[ExternalEditorManager] 启动外部编辑器
    ↓
[SyncManager] 启动文件监控（可选）
    ↓
用户编辑并保存
    ↓
[SyncManager] 检测到文件变化
    ↓
[Importer] 导入修改后的内容
    ↓
更新 Joplin 中的笔记
```

### 3.5 状态管理

需要维护以下状态：

```typescript
interface EditingSession {
  noteId: string;           // Joplin 笔记 ID
  noteTitle: string;        // 笔记标题
  tempDir: string;          // 临时目录路径
  tempFilePath: string;     // 临时文件路径
  editorProcess?: any;      // 编辑器进程
  fileWatcher?: fs.FSWatcher; // 文件监控器
  isEditing: boolean;       // 是否正在编辑
}
```

### 3.6 错误处理

#### 错误场景 1: 获取当前笔记失败

**处理方式**：
- 显示错误提示："无法获取当前笔记"
- 禁用按钮状态

#### 错误场景 2: 导出失败

**处理方式**：
- 显示错误提示："导出失败"
- 清理临时文件
- 记录详细日志

#### 错误场景 3: 启动外部编辑器失败

**处理方式**：
- 显示错误提示："无法启动外部编辑器"
- 提示用户检查编辑器路径配置

#### 错误场景 4: 导入失败

**处理方式**：
- 显示错误提示："导入失败"
- 保留临时文件供手动恢复
- 记录详细日志

### 3.7 设置项

在 `settings.ts` 中添加新的设置项：

```typescript
export const SETTINGS_KEYS = {
  // ... 现有设置
  EXTERNAL_EDITOR_PATH: "externalEditorPath",
  TEMP_DIR_PATH: "tempDirPath",
  AUTO_SYNC: "autoSync",
  SYNC_INTERVAL: "syncInterval",
} as const;

const settingsConfig: Record<string, any> = {
  // ... 现有设置
  [SETTINGS_KEYS.EXTERNAL_EDITOR_PATH]: {
    type: SettingItemType.String,
    value: "Typora",  // 或编辑器的完整路径
    label: "外部编辑器路径",
    description: "指定用于打开笔记的外部编辑器（如 Typora、VS Code）",
    public: true,
    section: SETTINGS_SECTION,
    advanced: false,
  },
  [SETTINGS_KEYS.TEMP_DIR_PATH]: {
    type: SettingItemType.String,
    value: "",
    label: "临时目录",
    description: "指定临时导出文件的目录，留空则使用系统默认临时目录",
    public: true,
    section: SETTINGS_SECTION,
    advanced: true,
  },
  [SETTINGS_KEYS.AUTO_SYNC]: {
    type: SettingItemType.Bool,
    value: false,
    label: "自动同步",
    description: "检测到文件修改时自动同步回 Joplin",
    public: true,
    section: SETTINGS_SECTION,
    advanced: false,
  },
  [SETTINGS_KEYS.SYNC_INTERVAL]: {
    type: SettingItemType.Int,
    value: 5000,
    label: "同步间隔（毫秒）",
    description: "文件变化后等待的时间，用于防抖",
    public: true,
    section: SETTINGS_SECTION,
    advanced: true,
  },
};
```

## 四、实现步骤

### 阶段 1: 基础框架

1. 创建 `src/toolbarButton.ts` - 工具栏按钮注册
2. 创建 `src/externalEditor.ts` - 外部编辑器启动逻辑
3. 在 `src/index.ts` 中集成新组件
4. 添加相关设置项

### 阶段 2: 导出功能

1. 在 `src/exporter.ts` 中添加 `exportNoteToPath()` 函数
2. 实现单个笔记导出到指定路径
3. 测试导出功能

### 阶段 3: 编辑器集成

1. 实现外部编辑器启动逻辑
2. 处理不同平台的路径问题
3. 测试编辑器启动

### 阶段 4: 导入功能

1. 修改 `src/importer.ts` 支持更新现有笔记
2. 实现导入逻辑
3. 测试导入功能

### 阶段 5: 文件监控（可选）

1. 创建 `src/syncManager.ts`
2. 实现文件变化监控
3. 实现自动同步逻辑
4. 添加防抖机制

### 阶段 6: 优化和完善

1. 添加状态提示
2. 完善错误处理
3. 添加日志记录
4. 编写测试用例

## 五、注意事项

### 5.1 并发问题

- 用户可能同时打开多个笔记在外部编辑器中
- 需要维护多个编辑会话的状态
- 使用 Map 存储多个会话：`Map<string, EditingSession>`

### 5.2 资源清理

- 编辑完成后需要清理临时文件
- Joplin 关闭时需要清理所有临时文件

### 5.3 冲突处理

- 当用户在外部编辑器和 Joplin 中同时修改笔记时，需要提示用户
- 提供合并或覆盖选项

### 5.4 平台兼容性

- Windows 路径使用反斜杠 `\`
- macOS 和 Linux 使用正斜杠 `/`
- 使用 `path.join()` 自动处理路径分隔符

## 六、参考资源

### 6.1 Joplin API 文档

- [Joplin Views ToolbarButtons](https://joplinapp.org/api/references/plugin_api/classes/joplinviewstoolbarbuttons/)
- [Joplin Commands](https://joplinapp.org/api/references/plugin_api/classes/joplincommands/)
- [Joplin Workspace](https://joplinapp.org/api/references/plugin_api/classes/joplinworkspace/)

### 6.2 相关插件

- [YesYouKan Plugin](https://github.com/joplin/plugin-yesyoukan) - 编辑器插件示例
- [External Editor Plugin](https://github.com/joplin/plugin-external-editor) - 外部编辑器插件

### 6.3 技术文档

- [Node.js child_process](https://nodejs.org/api/child_process.html)
- [chokidar](https://github.com/paulmillr/chokidar) - 文件监控库
- [fs-extra](https://github.com/jprichardson/node-fs-extra) - 文件系统操作库

## 七、总结

通过添加工具栏按钮，用户可以一键将当前笔记导出到外部编辑器进行编辑，然后再导入回 Joplin。整个过程可以完全自定义，包括导出格式、资源处理、导入逻辑等。

这个功能的核心优势在于：
1. **无缝集成**：直接在 Joplin 工具栏中操作，无需手动导出导入
2. **完全控制**：可以干预导出和导入的每个环节
3. **灵活扩展**：可以添加自定义的预处理和后处理逻辑
4. **用户体验**：提供流畅的编辑体验，类似于 Joplin 原生的外部编辑器功能

实现此功能需要以下新模块：
- `src/toolbarButton.ts` - 工具栏按钮管理
- `src/externalEditor.ts` - 外部编辑器管理
- `src/syncManager.ts` - 文件同步管理（可选）
- `src/tempFileManager.ts` - 临时文件管理（可选）

需要修改的现有模块：
- `src/exporter.ts` - 添加单个笔记导出功能
- `src/importer.ts` - 添加更新现有笔记功能
- `src/settings.ts` - 添加新的设置项
- `src/index.ts` - 集成新组件
